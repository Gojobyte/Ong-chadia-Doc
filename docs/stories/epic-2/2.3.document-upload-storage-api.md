# Story 2.3: Document Upload & Storage API

## Status

Draft

## Story

**As a** utilisateur avec permission WRITE,
**I want** uploader des documents dans un dossier,
**so that** je puisse centraliser mes fichiers dans la GED.

## Acceptance Criteria

1. Schéma Prisma `Document` : id, name, mimeType, size, storagePath, folderId, uploadedById, createdAt
2. Intégration Supabase Storage configurée
3. Endpoint `POST /api/documents/upload` acceptant multipart/form-data
4. Upload vers Supabase Storage avec path structuré (`/org/{folderId}/{uuid}_{filename}`)
5. Limite de taille : 50 MB par fichier
6. Types acceptés : PDF, Word (.doc, .docx), Excel (.xls, .xlsx), images (jpg, png, gif), txt
7. Validation du type MIME côté serveur (pas seulement extension)
8. Métadonnées stockées en DB, fichier dans Storage
9. Retourne le document créé avec URL signée temporaire
10. Gestion d'erreurs : quota dépassé, type non supporté, upload failed
11. Tests d'intégration avec mock Storage

## Tasks / Subtasks

- [ ] **Task 1: Configurer Supabase Storage** (AC: 2)
  - [ ] Ajouter `@supabase/supabase-js` aux dépendances API
  - [ ] Créer `apps/api/src/config/supabase.config.ts`
  - [ ] Configurer les variables d'environnement (SUPABASE_URL, SUPABASE_SERVICE_KEY)
  - [ ] Créer le bucket `documents` sur Supabase (si non existant)
  - [ ] Mettre à jour `.env.example`

- [ ] **Task 2: Créer le schéma Prisma Document** (AC: 1)
  - [ ] Ajouter le modèle `Document` dans `prisma/schema.prisma`
  - [ ] Définir les champs requis et relations (Folder, User)
  - [ ] Créer et exécuter la migration

- [ ] **Task 3: Créer les types partagés** (AC: 1, 6)
  - [ ] Créer `packages/shared/src/types/document.types.ts`
  - [ ] Définir `DocumentResponse`, `UploadDocumentDto`
  - [ ] Définir constantes : `ALLOWED_MIME_TYPES`, `MAX_FILE_SIZE`
  - [ ] Créer validateurs Zod

- [ ] **Task 4: Créer le service storage** (AC: 2, 4, 9)
  - [ ] Créer `apps/api/src/modules/documents/storage.service.ts`
  - [ ] Implémenter `uploadFile(file, folderId)` → retourne storagePath
  - [ ] Implémenter `getSignedUrl(storagePath, expiresIn)` → URL temporaire
  - [ ] Implémenter `deleteFile(storagePath)`
  - [ ] Générer path structuré : `/org/{folderId}/{uuid}_{filename}`

- [ ] **Task 5: Créer le service documents** (AC: 1, 3, 5-10)
  - [ ] Créer `apps/api/src/modules/documents/documents.service.ts`
  - [ ] Implémenter `uploadDocument(file, folderId, userId)`
  - [ ] Valider le type MIME avec `file-type` ou magic bytes
  - [ ] Valider la taille (50 MB max)
  - [ ] Appeler storage.service pour l'upload
  - [ ] Sauvegarder les métadonnées en DB
  - [ ] Retourner le document avec URL signée

- [ ] **Task 6: Créer le contrôleur et routes upload** (AC: 3)
  - [ ] Installer `multer` pour multipart/form-data
  - [ ] Créer `apps/api/src/modules/documents/documents.controller.ts`
  - [ ] Créer `apps/api/src/modules/documents/documents.routes.ts`
  - [ ] Route `POST /api/documents/upload` avec multer middleware
  - [ ] Appliquer middleware `authenticate` + `canAccessFolder(WRITE)`

- [ ] **Task 7: Implémenter la gestion d'erreurs** (AC: 10)
  - [ ] Créer erreurs custom : `FileTooLargeError`, `UnsupportedFileTypeError`, `StorageQuotaExceededError`
  - [ ] Handler d'erreur global pour ces cas
  - [ ] Retourner messages clairs au client

- [ ] **Task 8: Écrire les tests** (AC: 11)
  - [ ] Créer mock pour Supabase Storage
  - [ ] Tester upload valide
  - [ ] Tester rejet fichier trop gros
  - [ ] Tester rejet type non supporté
  - [ ] Tester vérification permissions

## Dev Notes

### Structure des fichiers à créer/modifier

```
apps/api/
  src/
    config/
      supabase.config.ts     # Nouveau
    modules/documents/
      documents.service.ts   # Nouveau
      documents.controller.ts # Nouveau
      documents.routes.ts    # Nouveau
      storage.service.ts     # Nouveau
      index.ts               # Nouveau
    common/errors/
      file.errors.ts         # Nouveau

packages/shared/src/
  types/document.types.ts    # Nouveau
  constants/file.constants.ts # Nouveau
```

### Schéma Prisma suggéré

```prisma
model Document {
  id           String   @id @default(cuid())
  name         String
  mimeType     String
  size         Int      // en bytes
  storagePath  String   @unique
  folderId     String
  folder       Folder   @relation(fields: [folderId], references: [id])
  uploadedById String
  uploadedBy   User     @relation(fields: [uploadedById], references: [id])
  createdAt    DateTime @default(now())

  @@map("documents")
}
```

### Types MIME acceptés

```typescript
export const ALLOWED_MIME_TYPES = [
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'image/jpeg',
  'image/png',
  'image/gif',
  'text/plain',
];

export const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB
```

### Validation MIME côté serveur

```typescript
import { fileTypeFromBuffer } from 'file-type';

async function validateMimeType(buffer: Buffer, declaredMime: string): Promise<boolean> {
  const detected = await fileTypeFromBuffer(buffer);
  // Pour les fichiers texte, file-type retourne undefined
  if (!detected && declaredMime === 'text/plain') return true;
  return detected?.mime === declaredMime && ALLOWED_MIME_TYPES.includes(declaredMime);
}
```

### Configuration Multer

```typescript
import multer from 'multer';

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: MAX_FILE_SIZE },
  fileFilter: (req, file, cb) => {
    if (ALLOWED_MIME_TYPES.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new UnsupportedFileTypeError(file.mimetype));
    }
  },
});
```

### Coding Standards

- **Jamais** exposer le storagePath directement au client
- Toujours retourner des URL signées avec expiration
- Vérifier permissions AVANT l'upload (pas après)

## Testing

### Mock Supabase Storage

```typescript
jest.mock('@supabase/supabase-js', () => ({
  createClient: () => ({
    storage: {
      from: () => ({
        upload: jest.fn().mockResolvedValue({ data: { path: 'mock-path' }, error: null }),
        createSignedUrl: jest.fn().mockResolvedValue({ data: { signedUrl: 'https://mock-url' }, error: null }),
        remove: jest.fn().mockResolvedValue({ data: null, error: null }),
      }),
    },
  }),
}));
```

### Cas de test

1. Upload PDF valide → 201 + document créé
2. Upload fichier > 50MB → 413 Payload Too Large
3. Upload .exe → 415 Unsupported Media Type
4. Upload sans permission WRITE → 403 Forbidden
5. Upload dans dossier inexistant → 404 Not Found

## Dependencies

- **Requires**: Story 2.1 (Folder Management), Story 2.2 (Folder Permissions)
- **Blocks**: Story 2.4 (Document Operations), Story 2.5 (Versioning)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-23 | 1.0 | Création initiale de la story | SM Agent (Bob) |
