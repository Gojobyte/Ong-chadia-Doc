# Story 2.6: Document Search API

## Status

Draft

## Story

**As a** utilisateur,
**I want** rechercher des documents par nom et métadonnées,
**so that** je puisse retrouver rapidement les fichiers dont j'ai besoin.

## Acceptance Criteria

1. Endpoint `GET /api/documents/search?q=terme` recherchant dans les noms de documents
2. Recherche insensible à la casse et aux accents
3. Recherche partielle (contient le terme, pas exact match)
4. Filtrage par type de fichier (`?type=pdf,docx`)
5. Filtrage par dossier et sous-dossiers (`?folderId=xxx&recursive=true`)
6. Filtrage par date (`?from=2026-01-01&to=2026-01-31`)
7. Résultats respectant les permissions de l'utilisateur (ne voit que ce qu'il peut accéder)
8. Pagination des résultats
9. Performance : résultats en < 1 seconde pour base de données MVP
10. Tests avec différents scénarios de recherche et permissions

## Tasks / Subtasks

- [ ] **Task 1: Créer les types de recherche** (AC: 1-6, 8)
  - [ ] Créer `packages/shared/src/types/search.types.ts`
  - [ ] Définir `SearchQueryParams` (q, type, folderId, recursive, from, to, page, limit)
  - [ ] Définir `SearchResultResponse`
  - [ ] Créer validateurs Zod pour tous les query params

- [ ] **Task 2: Créer le service de recherche** (AC: 1-6, 9)
  - [ ] Créer `apps/api/src/modules/documents/search.service.ts`
  - [ ] Implémenter `searchDocuments(params, userId)`
  - [ ] Construire la requête Prisma dynamiquement selon les filtres
  - [ ] Utiliser `mode: 'insensitive'` pour la recherche case-insensitive
  - [ ] Implémenter recherche partielle avec `contains`

- [ ] **Task 3: Implémenter le filtrage par permissions** (AC: 7)
  - [ ] Récupérer la liste des dossiers accessibles par l'utilisateur
  - [ ] Filtrer les résultats pour n'inclure que les documents dans ces dossiers
  - [ ] Optimiser : utiliser une sous-requête ou JOIN

- [ ] **Task 4: Implémenter la recherche récursive** (AC: 5)
  - [ ] Si `recursive=true`, inclure tous les sous-dossiers
  - [ ] Utiliser une CTE (Common Table Expression) ou récursion pour lister tous les descendants
  - [ ] Alternative : stocker le path complet pour recherche avec `startsWith`

- [ ] **Task 5: Normalisation des accents** (AC: 2)
  - [ ] Créer helper `normalizeString(str)` pour retirer les accents
  - [ ] Option 1: Utiliser extension PostgreSQL `unaccent`
  - [ ] Option 2: Normaliser côté application (moins performant)
  - [ ] Stocker un champ `nameNormalized` pour recherche optimisée

- [ ] **Task 6: Ajouter la route de recherche** (AC: 1)
  - [ ] `GET /api/documents/search` → `searchDocuments`
  - [ ] Middleware `authenticate`
  - [ ] Validation des query params avec Zod

- [ ] **Task 7: Écrire les tests** (AC: 10)
  - [ ] Tester recherche simple par nom
  - [ ] Tester recherche insensible casse/accents
  - [ ] Tester filtres combinés (type + date + dossier)
  - [ ] Tester recherche récursive
  - [ ] Tester respect des permissions
  - [ ] Tester pagination

## Dev Notes

### Structure des fichiers à créer/modifier

```
packages/shared/src/
  types/search.types.ts      # Nouveau

apps/api/src/
  modules/documents/
    search.service.ts        # Nouveau
    documents.routes.ts      # Ajouter route search
  utils/
    string.utils.ts          # Helper normalizeString
```

### Requête Prisma avec filtres dynamiques

```typescript
async function searchDocuments(params: SearchQueryParams, userId: string) {
  const { q, type, folderId, recursive, from, to, page = 1, limit = 50 } = params;

  // 1. Récupérer les dossiers accessibles
  const accessibleFolderIds = await getAccessibleFolderIds(userId);

  // 2. Construire les conditions WHERE
  const where: Prisma.DocumentWhereInput = {
    folderId: { in: accessibleFolderIds },
  };

  // Recherche par nom
  if (q) {
    where.name = {
      contains: q,
      mode: 'insensitive',
    };
  }

  // Filtrer par type MIME
  if (type) {
    const types = type.split(',');
    const mimeTypes = types.flatMap(t => MIME_TYPE_MAP[t] || []);
    where.mimeType = { in: mimeTypes };
  }

  // Filtrer par dossier
  if (folderId) {
    if (recursive) {
      const descendantIds = await getDescendantFolderIds(folderId);
      where.folderId = { in: descendantIds.filter(id => accessibleFolderIds.includes(id)) };
    } else {
      where.folderId = folderId;
    }
  }

  // Filtrer par date
  if (from || to) {
    where.createdAt = {};
    if (from) where.createdAt.gte = new Date(from);
    if (to) where.createdAt.lte = new Date(to);
  }

  // 3. Exécuter la requête paginée
  const [documents, total] = await Promise.all([
    prisma.document.findMany({
      where,
      skip: (page - 1) * limit,
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: { folder: { select: { name: true } } },
    }),
    prisma.document.count({ where }),
  ]);

  return {
    data: documents,
    pagination: { page, limit, total, totalPages: Math.ceil(total / limit) },
  };
}
```

### Map des types de fichiers

```typescript
const MIME_TYPE_MAP: Record<string, string[]> = {
  pdf: ['application/pdf'],
  doc: ['application/msword'],
  docx: ['application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
  xls: ['application/vnd.ms-excel'],
  xlsx: ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'],
  image: ['image/jpeg', 'image/png', 'image/gif'],
  txt: ['text/plain'],
};
```

### Récupération récursive des sous-dossiers

```typescript
async function getDescendantFolderIds(folderId: string): Promise<string[]> {
  const result: string[] = [folderId];

  const children = await prisma.folder.findMany({
    where: { parentId: folderId },
    select: { id: true },
  });

  for (const child of children) {
    const descendants = await getDescendantFolderIds(child.id);
    result.push(...descendants);
  }

  return result;
}

// Alternative avec CTE PostgreSQL (plus performant pour grandes hiérarchies)
// Utiliser $queryRaw si nécessaire
```

### Normalisation des accents

```typescript
function normalizeString(str: string): string {
  return str
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .toLowerCase();
}

// Exemple: "Réunion" → "reunion"
```

### Performance

- Index sur `documents.name` pour la recherche
- Index sur `documents.folderId` pour le filtrage
- Index sur `documents.createdAt` pour le tri et filtrage par date
- Limiter la pagination à max 100 résultats par page

## Testing

### Cas de test requis

1. **Recherche simple**
   - `?q=rapport` → trouve "Rapport annuel.pdf", "rapport_2024.docx"
   - `?q=RAPPORT` → même résultat (case insensitive)
   - `?q=réunion` et `?q=reunion` → même résultat (accents)

2. **Filtres**
   - `?type=pdf` → uniquement les PDF
   - `?type=pdf,docx` → PDF et Word
   - `?from=2026-01-01&to=2026-01-31` → documents de janvier
   - `?folderId=xxx` → documents du dossier spécifique
   - `?folderId=xxx&recursive=true` → inclut sous-dossiers

3. **Permissions**
   - User A cherche → ne voit que ses dossiers accessibles
   - Document dans dossier restreint → invisible dans recherche

4. **Pagination**
   - `?page=2&limit=10` → skip 10, take 10
   - Vérifier totalPages correct

5. **Performance**
   - Mesurer temps de réponse < 1s avec 1000 documents

## Dependencies

- **Requires**: Story 2.3 (Document Upload), Story 2.4 (Document Operations), Story 2.2 (Permissions)
- **Blocks**: Story 2.7 (UI) - pour la barre de recherche

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-23 | 1.0 | Création initiale de la story | SM Agent (Bob) |
