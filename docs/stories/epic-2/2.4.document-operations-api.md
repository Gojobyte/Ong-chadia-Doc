# Story 2.4: Document Operations API

## Status

Draft

## Story

**As a** utilisateur avec permissions appropriées,
**I want** télécharger, renommer, déplacer et supprimer des documents,
**so that** je puisse gérer mes fichiers efficacement.

## Acceptance Criteria

1. Endpoint `GET /api/documents/:id` récupérant les métadonnées d'un document
2. Endpoint `GET /api/documents/:id/download` retournant une URL signée pour téléchargement
3. Endpoint `GET /api/folders/:id/documents` listant les documents d'un dossier
4. Endpoint `PATCH /api/documents/:id` modifiant name ou folderId (déplacement)
5. Endpoint `DELETE /api/documents/:id` supprimant le document (Storage + DB)
6. Vérification des permissions : READ pour voir/télécharger, WRITE pour modifier/supprimer
7. Lors du déplacement, vérifier permission WRITE sur dossier source ET destination
8. Pagination sur la liste des documents (`?page=1&limit=50`)
9. Tri par nom, date, taille (`?sort=createdAt&order=desc`)
10. Tests d'intégration couvrant tous les cas de permissions

## Tasks / Subtasks

- [ ] **Task 1: Étendre les types partagés** (AC: 1-5, 8-9)
  - [ ] Ajouter `UpdateDocumentDto` dans `packages/shared/src/types/document.types.ts`
  - [ ] Ajouter `DocumentListQueryParams` (page, limit, sort, order)
  - [ ] Créer validateurs Zod pour les query params

- [ ] **Task 2: Étendre le service documents** (AC: 1-5, 8-9)
  - [ ] Implémenter `getDocumentById(id)` - métadonnées
  - [ ] Implémenter `getDownloadUrl(id)` - URL signée (via storage.service)
  - [ ] Implémenter `listDocumentsByFolder(folderId, pagination, sort)`
  - [ ] Implémenter `updateDocument(id, data)` - renommer ou déplacer
  - [ ] Implémenter `deleteDocument(id)` - supprimer Storage + DB

- [ ] **Task 3: Implémenter la logique de déplacement** (AC: 7)
  - [ ] Créer méthode `moveDocument(documentId, targetFolderId, userId)`
  - [ ] Vérifier permission WRITE sur dossier source
  - [ ] Vérifier permission WRITE sur dossier destination
  - [ ] Mettre à jour le folderId en DB (storagePath reste inchangé dans Storage)

- [ ] **Task 4: Ajouter les routes au contrôleur** (AC: 1-5)
  - [ ] `GET /api/documents/:id` → `getDocumentById` + `canAccessFolder(READ)`
  - [ ] `GET /api/documents/:id/download` → `getDownloadUrl` + `canAccessFolder(READ)`
  - [ ] `GET /api/folders/:id/documents` → `listDocumentsByFolder` + `canAccessFolder(READ)`
  - [ ] `PATCH /api/documents/:id` → `updateDocument` + `canAccessFolder(WRITE)`
  - [ ] `DELETE /api/documents/:id` → `deleteDocument` + `canAccessFolder(WRITE)`

- [ ] **Task 5: Implémenter la pagination et le tri** (AC: 8-9)
  - [ ] Parser query params (page, limit, sort, order)
  - [ ] Valider les champs de tri autorisés (name, createdAt, size)
  - [ ] Retourner format standard : `{ data: [...], pagination: { page, limit, total, totalPages } }`

- [ ] **Task 6: Écrire les tests** (AC: 10)
  - [ ] Tester récupération métadonnées avec permission READ
  - [ ] Tester téléchargement avec permission READ
  - [ ] Tester listing avec pagination
  - [ ] Tester renommage avec permission WRITE
  - [ ] Tester déplacement avec WRITE sur source ET destination
  - [ ] Tester suppression avec permission WRITE
  - [ ] Tester refus sans permissions appropriées

## Dev Notes

### Structure des fichiers à modifier

```
packages/shared/src/
  types/document.types.ts    # Étendre
  validators/document.validators.ts  # Étendre

apps/api/src/
  modules/documents/
    documents.service.ts     # Étendre
    documents.controller.ts  # Étendre
    documents.routes.ts      # Étendre
```

### Logique de vérification des permissions pour les documents

```typescript
// Middleware personnalisé pour les documents
async function canAccessDocument(permission: Permission) {
  return async (req, res, next) => {
    const documentId = req.params.id;
    const document = await prisma.document.findUnique({
      where: { id: documentId },
      select: { folderId: true }
    });

    if (!document) return res.status(404).json({ error: 'Document not found' });

    // Utiliser le middleware canAccessFolder existant
    req.params.folderId = document.folderId;
    return canAccessFolder(permission)(req, res, next);
  };
}
```

### Format de réponse paginée

```typescript
interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

// Exemple d'utilisation
const [documents, total] = await Promise.all([
  prisma.document.findMany({
    where: { folderId },
    skip: (page - 1) * limit,
    take: limit,
    orderBy: { [sort]: order },
  }),
  prisma.document.count({ where: { folderId } }),
]);

return {
  data: documents,
  pagination: {
    page,
    limit,
    total,
    totalPages: Math.ceil(total / limit),
  },
};
```

### Tri autorisé

```typescript
const ALLOWED_SORT_FIELDS = ['name', 'createdAt', 'size'] as const;
const ALLOWED_ORDER = ['asc', 'desc'] as const;

// Validation
const sortField = ALLOWED_SORT_FIELDS.includes(sort) ? sort : 'createdAt';
const sortOrder = ALLOWED_ORDER.includes(order) ? order : 'desc';
```

### Suppression complète

```typescript
async function deleteDocument(id: string): Promise<void> {
  const document = await prisma.document.findUnique({ where: { id } });
  if (!document) throw new NotFoundError('Document');

  // 1. Supprimer du Storage
  await storageService.deleteFile(document.storagePath);

  // 2. Supprimer de la DB
  await prisma.document.delete({ where: { id } });
}
```

### Coding Standards

- **API Response format obligatoire** pour les listes paginées
- Vérifier permissions AVANT toute opération
- Pour le déplacement, ne pas déplacer le fichier dans Storage (coûteux), juste mettre à jour la référence en DB

## Testing

### Cas de test requis

1. **Métadonnées**
   - GET document avec READ → 200 + métadonnées
   - GET document sans permission → 403
   - GET document inexistant → 404

2. **Téléchargement**
   - GET download avec READ → 200 + URL signée
   - URL doit expirer (vérifier format)

3. **Listing**
   - GET documents avec pagination → vérifier page, limit, total
   - GET documents avec tri → vérifier ordre
   - GET documents dossier vide → data: [], total: 0

4. **Modification**
   - PATCH nom avec WRITE → 200 + document mis à jour
   - PATCH folderId (déplacement) avec WRITE source + dest → 200
   - PATCH folderId sans WRITE destination → 403

5. **Suppression**
   - DELETE avec WRITE → 204
   - DELETE sans WRITE → 403
   - Vérifier suppression Storage + DB

## Dependencies

- **Requires**: Story 2.3 (Document Upload & Storage)
- **Blocks**: Story 2.5 (Versioning), Story 2.7-2.9 (UI)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-23 | 1.0 | Création initiale de la story | SM Agent (Bob) |
