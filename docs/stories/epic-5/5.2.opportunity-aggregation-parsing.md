# Story 5.2: Opportunity Aggregation & Parsing

## Status: Approved

## Story

**As a** système,
**I want** collecter et parser les appels d'offres depuis les sources configurées,
**so that** les données soient normalisées et exploitables.

## Acceptance Criteria

1. Job planifié (CRON/BullMQ) pour collecte automatique selon fréquence source
2. Parsing des données selon format source (RSS XML, JSON API, HTML scraping)
3. Normalisation vers schéma commun: titre, bailleur, deadline, montant, secteurs, zones
4. Détection des doublons via hash titre+bailleur+deadline
5. Stockage en base avec statut initial "NEW"
6. Extraction automatique des tags/mots-clés depuis description
7. Gestion des erreurs de parsing avec retry (max 3)
8. File d'attente BullMQ pour traitement asynchrone
9. Métriques de collecte accessibles (dashboard admin)
10. Tests unitaires parsing pour chaque type de source

## Tasks / Subtasks

- [ ] **Task 1: Schéma Prisma Opportunity** (AC: 3, 4, 5)
  - [ ] Créer model `Opportunity` avec champs normalisés
  - [ ] Champs: title, description, donor, deadline, amount, currency, sectors, regions, sourceUrl, sourceId, status
  - [ ] Créer enum `OpportunityStatus`: NEW, VIEWED, APPLIED, ARCHIVED
  - [ ] Index unique pour détection doublons
  - [ ] Migration Prisma

- [ ] **Task 2: Setup BullMQ** (AC: 1, 8)
  - [ ] Installer `bullmq ioredis`
  - [ ] Créer queue `opportunity-collection`
  - [ ] Créer worker pour traitement
  - [ ] Dashboard Bull Board (optionnel)

- [ ] **Task 3: Scheduler Jobs** (AC: 1)
  - [ ] Créer `collection-scheduler.service.ts`
  - [ ] Planifier jobs selon fréquence de chaque source
  - [ ] Ajouter job à la queue avec sourceId
  - [ ] Mettre à jour nextRunAt après exécution

- [ ] **Task 4: Collector Base Class** (AC: 2)
  - [ ] Créer classe abstraite `BaseCollector`
  - [ ] Méthodes: fetch(), parse(), normalize()
  - [ ] Gestion erreurs et retry
  - [ ] Logging standardisé

- [ ] **Task 5: RSS Collector** (AC: 2)
  - [ ] Créer `RssCollector` extends BaseCollector
  - [ ] Fetch RSS feed
  - [ ] Parser XML vers items
  - [ ] Mapper vers schéma Opportunity

- [ ] **Task 6: API Collector** (AC: 2)
  - [ ] Créer `ApiCollector` extends BaseCollector
  - [ ] Support auth (API key, OAuth)
  - [ ] Parser JSON response
  - [ ] Pagination automatique si supportée

- [ ] **Task 7: Scraping Collector** (AC: 2)
  - [ ] Créer `ScrapingCollector` extends BaseCollector
  - [ ] Utiliser Cheerio ou Puppeteer (si JS requis)
  - [ ] Extraire données via selectors CSS
  - [ ] Gestion anti-bot (délais, user-agent)

- [ ] **Task 8: Normalisation et Enrichissement** (AC: 3, 6)
  - [ ] Créer `normalizer.service.ts`
  - [ ] Normaliser devises vers EUR (si montant présent)
  - [ ] Normaliser dates vers ISO
  - [ ] Extraire tags via NLP simple ou regex (secteurs, pays)
  - [ ] Nettoyer HTML du texte

- [ ] **Task 9: Détection Doublons** (AC: 4)
  - [ ] Générer hash: SHA256(title + donor + deadline)
  - [ ] Vérifier existence avant insert
  - [ ] Mettre à jour si existant (updatedAt)
  - [ ] Logger doublons détectés

- [ ] **Task 10: Métriques et Monitoring** (AC: 9)
  - [ ] Endpoint `GET /api/monitoring/stats`
  - [ ] Compteurs: total collecté, par source, erreurs
  - [ ] Graphique tendance derniers 30 jours
  - [ ] Widget dashboard admin

- [ ] **Task 11: Tests** (AC: 10)
  - [ ] Tests RSS Collector avec fixtures
  - [ ] Tests API Collector avec mocks
  - [ ] Tests normalisation
  - [ ] Tests détection doublons

## Dev Notes

### Architecture

```text
apps/api/src/modules/monitoring/
├── collectors/
│   ├── base.collector.ts       # Classe abstraite
│   ├── rss.collector.ts
│   ├── api.collector.ts
│   ├── scraping.collector.ts
│   └── index.ts
├── jobs/
│   ├── collection.worker.ts    # BullMQ worker
│   ├── collection.scheduler.ts # Planificateur
│   └── queues.ts               # Config queues
├── services/
│   ├── normalizer.service.ts
│   ├── deduplicator.service.ts
│   └── metrics.service.ts
└── index.ts
```

### Schéma Prisma

```prisma
enum OpportunityStatus {
  NEW
  VIEWED
  APPLIED
  ARCHIVED
  REJECTED
}

model Opportunity {
  id            String            @id @default(uuid())
  sourceId      String
  source        MonitoringSource  @relation(fields: [sourceId], references: [id])
  externalId    String?           // ID dans la source originale
  contentHash   String            // Pour déduplication

  title         String
  description   String?           @db.Text
  donor         String?           // Nom du bailleur
  donorType     String?           // Bilatéral, Multilatéral, Fondation

  deadline      DateTime?
  publishedAt   DateTime?
  amount        Decimal?          @db.Decimal(15, 2)
  amountMin     Decimal?          @db.Decimal(15, 2)
  amountMax     Decimal?          @db.Decimal(15, 2)
  currency      String            @default("EUR")

  sectors       String[]          // Agriculture, Santé, Education...
  regions       String[]          // Afrique, Asie, Pays spécifiques
  eligibility   String?           // Critères d'éligibilité

  sourceUrl     String            // Lien vers l'original
  attachments   Json?             // URLs pièces jointes

  status        OpportunityStatus @default(NEW)
  viewedAt      DateTime?
  viewedById    String?

  tags          String[]          // Tags extraits automatiquement

  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  notes         OpportunityNote[]

  @@unique([sourceId, contentHash])
  @@index([status, deadline])
  @@index([donor])
  @@index([sectors])
  @@index([regions])
}
```

### BullMQ Worker

```ts
// apps/api/src/modules/monitoring/jobs/collection.worker.ts
import { Worker, Job } from 'bullmq';
import { CollectorFactory } from '../collectors';

const worker = new Worker('opportunity-collection', async (job: Job) => {
  const { sourceId } = job.data;

  const source = await getSource(sourceId);
  const collector = CollectorFactory.create(source.type);

  try {
    const rawItems = await collector.fetch(source.config);
    const opportunities = await collector.parse(rawItems);
    const normalized = await normalizer.normalize(opportunities);
    const { inserted, updated, duplicates } = await saveOpportunities(normalized, sourceId);

    await logSuccess(sourceId, { inserted, updated, duplicates });
    return { success: true, inserted, updated };
  } catch (error) {
    await logError(sourceId, error);
    throw error; // Pour retry
  }
}, {
  connection: redisConnection,
  limiter: { max: 5, duration: 1000 }, // Rate limiting
});
```

### Normalisation Exemple

```ts
interface RawOpportunity {
  title: string;
  deadline?: string;
  budget?: string;
  // ...
}

function normalize(raw: RawOpportunity): Partial<Opportunity> {
  return {
    title: sanitizeHtml(raw.title),
    deadline: parseDate(raw.deadline),
    amount: parseAmount(raw.budget)?.value,
    currency: parseAmount(raw.budget)?.currency || 'EUR',
    sectors: extractSectors(raw.title + ' ' + raw.description),
    regions: extractRegions(raw.description),
  };
}

function extractSectors(text: string): string[] {
  const sectorKeywords = {
    'health': 'Santé',
    'education': 'Éducation',
    'agriculture': 'Agriculture',
    // ...
  };
  return Object.entries(sectorKeywords)
    .filter(([keyword]) => text.toLowerCase().includes(keyword))
    .map(([, sector]) => sector);
}
```

## Testing

### Localisation

- `apps/api/src/modules/monitoring/collectors/__tests__/`
- `apps/api/src/modules/monitoring/services/__tests__/`

### Framework

- Jest + nock pour mocking HTTP

### Cas à couvrir

| Test | Description |
|------|-------------|
| RSS parse | Parser RSS valide |
| RSS invalid | Gestion RSS malformé |
| API auth | Authentification API key |
| API pagination | Collecte multi-pages |
| Normalize date | Formats dates divers |
| Normalize amount | "50,000 EUR" → 50000 |
| Dedupe | Même opportunité non dupliquée |
| Retry | Retry après échec temporaire |

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Création initiale de la story | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
<!-- Populated by dev agent -->

### Debug Log References
<!-- Populated by dev agent -->

### Completion Notes List
<!-- Populated by dev agent -->

### File List
<!-- Populated by dev agent -->

---

## QA Results
<!-- Populated by QA agent -->
