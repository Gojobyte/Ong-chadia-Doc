# Story 9.4: Photo Capture with Geolocation

## Status: Approved

## Story

**As a** agent terrain,
**I want** prendre des photos g√©olocalis√©es depuis l'application,
**so that** je puisse documenter mes activit√©s avec preuve visuelle et localisation.

## Acceptance Criteria

1. Acc√®s cam√©ra depuis l'application via Web API (navigator.mediaDevices)
2. Capture photo avec m√©tadonn√©es automatiques
3. G√©olocalisation automatique (latitude, longitude, accuracy)
4. Horodatage automatique (date et heure pr√©cises)
5. Annotation des photos (texte, fl√®ches, formes basiques)
6. Compression automatique pour optimiser stockage (max 1920px, quality 80%)
7. Galerie photos par projet avec filtres
8. Association photo √† un formulaire, document ou activit√©
9. Visualisation sur carte des photos g√©olocalis√©es
10. Fonctionnement en mode offline avec synchronisation ult√©rieure
11. Tests couvrant capture, annotation, et stockage

## Tasks / Subtasks

- [ ] **Task 1: Composant Camera Capture** (AC: 1, 2)
  - [ ] Cr√©er `CameraCapture.tsx`
  - [ ] Acc√®s cam√©ra via `navigator.mediaDevices.getUserMedia`
  - [ ] Preview live vid√©o
  - [ ] Bouton capture
  - [ ] Switch cam√©ra front/back sur mobile
  - [ ] Gestion permissions refus√©es

- [ ] **Task 2: Capture G√©oloc et Horodatage** (AC: 3, 4)
  - [ ] Cr√©er `useGeolocation.ts` hook
  - [ ] Capturer position au moment du shot
  - [ ] Capturer timestamp pr√©cis
  - [ ] Stocker dans metadata photo

- [ ] **Task 3: Compression Image** (AC: 6)
  - [ ] Cr√©er `image-compression.ts` utility
  - [ ] Resize si > 1920px (c√¥t√© le plus long)
  - [ ] Compression JPEG quality 80%
  - [ ] Conserver orientation EXIF
  - [ ] Retourner Blob compress√©

- [ ] **Task 4: Annotation Photos** (AC: 5)
  - [ ] Installer librairie canvas annotation (react-canvas-draw ou custom)
  - [ ] Cr√©er `PhotoAnnotator.tsx`
  - [ ] Outils: texte, fl√®che, rectangle, cercle, ligne
  - [ ] Couleurs: rouge, jaune, bleu, noir
  - [ ] Undo/redo
  - [ ] Sauvegarder image avec annotations fusionn√©es

- [ ] **Task 5: API Photos** (AC: 7, 8)
  - [ ] Cr√©er model `Photo` dans Prisma
  - [ ] `POST /api/photos` - Upload photo
  - [ ] `GET /api/projects/:id/photos` - Liste photos projet
  - [ ] `PATCH /api/photos/:id` - Modifier metadata
  - [ ] `DELETE /api/photos/:id` - Supprimer
  - [ ] Liens: projectId, formSubmissionId?, documentId?, activityId?

- [ ] **Task 6: Upload vers Storage** (AC: 6)
  - [ ] Upload vers Supabase Storage bucket photos
  - [ ] Nommage: `{projectId}/{timestamp}_{uuid}.jpg`
  - [ ] Stocker URL et metadata en base
  - [ ] G√©n√©rer thumbnail (300px) pour liste

- [ ] **Task 7: Galerie Photos** (AC: 7)
  - [ ] Cr√©er `PhotoGallery.tsx`
  - [ ] Affichage grille avec thumbnails
  - [ ] Filtres: date, auteur, avec/sans g√©oloc
  - [ ] Clic pour voir en grand avec d√©tails
  - [ ] Actions: t√©l√©charger, supprimer, annoter

- [ ] **Task 8: Association Photos** (AC: 8)
  - [ ] `PhotoField.tsx` pour formulaires dynamiques
  - [ ] Bouton "Ajouter photo" dans documents
  - [ ] S√©lectionneur photos existantes ou nouvelle capture

- [ ] **Task 9: Carte Photos G√©olocalis√©es** (AC: 9)
  - [ ] Int√©grer Mapbox ou Leaflet
  - [ ] Cr√©er `PhotoMap.tsx`
  - [ ] Marqueurs pour chaque photo avec position
  - [ ] Cluster si beaucoup de photos proches
  - [ ] Clic marqueur ‚Üí preview photo

- [ ] **Task 10: Mode Offline** (AC: 10)
  - [ ] Stocker photos en IndexedDB via Dexie
  - [ ] Queue d'upload pour sync
  - [ ] Indicateur photos en attente
  - [ ] Sync automatique au retour online

- [ ] **Task 11: Tests** (AC: 11)
  - [ ] Tests capture (mock mediaDevices)
  - [ ] Tests compression
  - [ ] Tests annotation
  - [ ] Tests galerie
  - [ ] Tests offline storage

## Dev Notes

### Architecture

```text
apps/api/src/modules/photos/
‚îú‚îÄ‚îÄ photos.controller.ts
‚îú‚îÄ‚îÄ photos.service.ts
‚îú‚îÄ‚îÄ photos.routes.ts
‚îî‚îÄ‚îÄ thumbnail.service.ts

apps/web/src/components/photos/
‚îú‚îÄ‚îÄ CameraCapture.tsx         # Capture cam√©ra
‚îú‚îÄ‚îÄ PhotoAnnotator.tsx        # Annotation
‚îú‚îÄ‚îÄ PhotoGallery.tsx          # Galerie
‚îú‚îÄ‚îÄ PhotoPreview.tsx          # Vue d√©tail
‚îú‚îÄ‚îÄ PhotoMap.tsx              # Carte
‚îú‚îÄ‚îÄ PhotoField.tsx            # Champ formulaire
‚îî‚îÄ‚îÄ index.ts

apps/web/src/lib/
‚îú‚îÄ‚îÄ image-compression.ts      # Compression
‚îî‚îÄ‚îÄ geolocation.ts            # Utilitaires g√©oloc

apps/web/src/hooks/
‚îú‚îÄ‚îÄ useCamera.ts              # Hook acc√®s cam√©ra
‚îî‚îÄ‚îÄ useGeolocation.ts         # Hook g√©oloc
```

### Sch√©ma Prisma

```prisma
model Photo {
  id                String   @id @default(uuid())
  projectId         String
  project           Project  @relation(fields: [projectId], references: [id])
  url               String   // URL Supabase Storage
  thumbnailUrl      String?  // URL thumbnail
  originalFilename  String?
  mimeType          String   @default("image/jpeg")
  size              Int      // En bytes
  width             Int?
  height            Int?
  latitude          Float?
  longitude         Float?
  accuracy          Float?   // Pr√©cision GPS en m√®tres
  takenAt           DateTime @default(now())
  caption           String?

  // Associations optionnelles
  formSubmissionId  String?
  formSubmission    FormSubmission? @relation(fields: [formSubmissionId], references: [id])
  documentId        String?
  document          Document? @relation(fields: [documentId], references: [id])

  uploadedById      String
  uploadedBy        User     @relation(fields: [uploadedById], references: [id])
  createdAt         DateTime @default(now())

  @@index([projectId, takenAt])
  @@index([latitude, longitude])
}
```

### Code Camera Capture

```tsx
// apps/web/src/components/photos/CameraCapture.tsx
import { useRef, useState, useCallback } from 'react';
import { useGeolocation } from '@/hooks/useGeolocation';

export function CameraCapture({ onCapture }: { onCapture: (photo: CapturedPhoto) => void }) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const [stream, setStream] = useState<MediaStream | null>(null);
  const { position, getPosition } = useGeolocation();

  const startCamera = useCallback(async () => {
    try {
      const mediaStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment', width: { ideal: 1920 } },
      });
      setStream(mediaStream);
      if (videoRef.current) {
        videoRef.current.srcObject = mediaStream;
      }
    } catch (error) {
      console.error('Camera access denied:', error);
    }
  }, []);

  const capture = useCallback(async () => {
    if (!videoRef.current) return;

    const canvas = document.createElement('canvas');
    canvas.width = videoRef.current.videoWidth;
    canvas.height = videoRef.current.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx?.drawImage(videoRef.current, 0, 0);

    const blob = await new Promise<Blob>((resolve) => {
      canvas.toBlob((b) => resolve(b!), 'image/jpeg', 0.8);
    });

    const geo = await getPosition();

    onCapture({
      blob,
      timestamp: new Date(),
      latitude: geo?.latitude,
      longitude: geo?.longitude,
      accuracy: geo?.accuracy,
    });
  }, [getPosition, onCapture]);

  return (
    <div className="relative">
      <video ref={videoRef} autoPlay playsInline className="w-full rounded-lg" />
      <div className="absolute bottom-4 left-1/2 transform -translate-x-1/2">
        <Button size="lg" onClick={capture} className="rounded-full w-16 h-16">
          üì∑
        </Button>
      </div>
    </div>
  );
}
```

### Compression Image

```ts
// apps/web/src/lib/image-compression.ts
export async function compressImage(file: File | Blob, maxSize = 1920, quality = 0.8): Promise<Blob> {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let { width, height } = img;

      // Resize si n√©cessaire
      if (width > maxSize || height > maxSize) {
        if (width > height) {
          height = (height / width) * maxSize;
          width = maxSize;
        } else {
          width = (width / height) * maxSize;
          height = maxSize;
        }
      }

      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');
      ctx?.drawImage(img, 0, 0, width, height);

      canvas.toBlob((blob) => resolve(blob!), 'image/jpeg', quality);
    };
    img.src = URL.createObjectURL(file);
  });
}
```

## Testing

### Localisation

- `apps/web/src/components/photos/__tests__/`
- `apps/web/src/lib/__tests__/image-compression.test.ts`

### Framework

- Vitest + React Testing Library
- Mock navigator.mediaDevices

### Cas √† couvrir

| Test | Description |
|------|-------------|
| Camera access | Permission demand√©e |
| Capture | Photo captur√©e avec metadata |
| Compression | Image redimensionn√©e si trop grande |
| Geoloc | Coordonn√©es attach√©es √† photo |
| Gallery render | Liste photos affich√©e |
| Map markers | Photos affich√©es sur carte |
| Offline | Photo stock√©e localement |
| Sync | Upload au retour online |

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | 1.0 | Cr√©ation initiale de la story | Sarah (PO) |

---

## Dev Agent Record

### Agent Model Used
<!-- Populated by dev agent -->

### Debug Log References
<!-- Populated by dev agent -->

### Completion Notes List
<!-- Populated by dev agent -->

### File List
<!-- Populated by dev agent -->

---

## QA Results
<!-- Populated by QA agent -->
